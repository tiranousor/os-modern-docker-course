# Архитектура Docker, изоляция и хранение данных

1. Из чего состоит Docker Engine

---

Docker на Linux-хосте состоит из трех частей:

1. **Docker Daemon (`dockerd`)**
   Фоновый процесс, который:

   * хранит информацию об образах, контейнерах, томах, сетях;
   * собирает образы, запускает/останавливает контейнеры.

2. **Docker REST API**

   * Интерфейс, через который с `dockerd` общаются внешние программы.
   * Docker CLI — всего лишь клиент к этому API.

3. **Docker CLI (`docker`)**

   * Командная утилита (`docker run`, `docker ps`, `docker images` и т.д.).
   * Может работать с **удаленным** Docker-хостом:

     ```bash
     docker -H tcp://10.10.10.1:2375 ps
     # или
     export DOCKER_HOST=tcp://10.10.10.1:2375
     docker ps
     ```

CLI и daemon необязательно находятся на одной машине.

2. Контейнер против виртуальной машины

---

* **Виртуальная машина (VM)**:

  * свое ядро ОС;
  * эмулированное «железо» (CPU, память, диск и т.д.);
  * тяжелая, долго запускается.

* **Контейнер**:

  * использует **ядро хоста**;
  * изоляция на уровне ядра (namespaces + cgroups);
  * легкий, быстро стартует.

Вывод: контейнер — это процесс с изоляцией.

3. Основные namespaces в Docker

---

Linux namespaces создают для процессов «свой мир»:

* `PID` — свое пространство процессов и свой `PID 1`
* `UTS` — свое имя хоста
* `NET` — свой сетевой стек (интерфейсы, маршруты, IP)
* `MNT` — свои точки монтирования (файловая система)

Контейнер видит только свой «мир», хотя физически все это те же ресурсы хоста.

4. PID namespace на примере

---

Без контейнеров:

* В Linux при загрузке стартует процесс с **PID = 1** (корневой).
* Остальные процессы — его потомки.

В контейнере:

* Внутри контейнера тоже есть **свой PID 1**.
* Тот же самый процесс на хосте имеет **другой PID**.

Пример:

* внутри контейнера:

  ```bash
  ps aux
  ```

  → `PID 1` — `bash`, `PID 10` — `ps`.

* на хосте:

  → тот же `bash` может иметь, например, `PID 2945`, а `ps` — `PID 3112`.

Один и тот же процесс имеет:

* PID в пространстве хоста;
* другой PID в пространстве контейнера.

5. Ограничение ресурсов: cgroups

---

По умолчанию контейнер может использовать все ресурсы хоста.
Через **cgroups** Docker умеет ограничивать:

* **CPU** — опция `--cpus`:

  ```bash
  docker run --cpus=0.5 nginx
  ```

  Контейнер не сможет использовать больше половины вычислительной мощности одного ядра.

* **Память** — опция `--memory`:

  ```bash
  docker run --memory=100m nginx
  ```

  Контейнеру доступно не больше 100 МБ. При превышении возможен OOM и падение контейнера.

Это важно, чтобы один «упавший» контейнер не положил всю машину.

6. Где Docker хранит свои данные

---

Основная служебная директория Docker:

```text
/var/lib/docker
```

Внутри:

* `containers/` — данные и метаданные контейнеров;
* `image/` — данные образов;
* `volumes/` — тома;
* `overlay2/` (или другой каталог в зависимости от драйвера) — слои файловых систем.

Студенты должны понимать: Docker ничего «волшебно не прячет», все лежит в обычной файловой системе.

7. Слои образа и слой контейнера

---

1. **Образ (image)** состоит из нескольких **read-only** слоев.
2. При запуске контейнера поверх этих слоев Docker добавляет **слой чтения/записи** (RW слой).

Поведение:

* исходные слои образа не меняются
* все изменения (новые файлы, логи, временные данные) попадают в RW слой контейнера
* при удалении контейнера RW слой пропадает, образ остается.

8. Copy-on-write (копирование при записи)

---

Если в образ «запечен» файл (например, `app.py`):

* пока файл только читают — он берется из слоя образа (read-only)
* при первой записи:

  1. Docker копирует файл из образа в RW слой контейнера
  2. изменения попадают **в копию**
  3. исходный файл в слое образа не меняется

Это и есть **copy-on-write**.
Образ всегда остается неизменяемым слепком, все правки — в слое контейнера.

9. Тома и bind mount’ы

---

Если хранить данные только в слое контейнера, то при удалении контейнера данные исчезают.
Для постоянных данных используются:

1. **Docker volume (именованный том)**

   * создается командой:

     ```bash
     docker volume create data_volume
     ```

   * физически лежит в:

     ```text
     /var/lib/docker/volumes/data_volume/_data
     ```

   * монтируется в контейнер:

     ```bash
     docker run -v data_volume:/var/lib/mysql mysql
     ```

   При удалении контейнера том и данные сохраняются.

2. **Bind mount**

   * монтирует **существующую директорию хоста**:

     ```bash
     docker run -v /data/mysql:/var/lib/mysql mysql
     ```

   * удобно, если данные уже лежат в `/data/mysql` или их нужно просматривать/редактировать на хосте.

Оба варианта позволяют сохранить данные независимо от жизни конкретного контейнера.

10. Storage drivers (драйверы хранилища)

---

За слои и поведение файловой системы в контейнерах отвечают **storage drivers**:

* пример: `overlay2`, `aufs`, `devicemapper`, `btrfs`, `zfs`;
* на современных Linux-системах чаще всего используется `overlay2`.

Драйвер:

* объединяет слои в единую видимую файловую систему
* реализует copy-on-write
* влияет на производительность и стабильность работы


