# Сети Docker (Docker Networking)

## 1. Какие сети Docker создает по умолчанию

После установки Docker на Linux-хосте автоматически появляются три сети:

* `bridge` — мостовая сеть по умолчанию
* `host` — использование сети хоста без изоляции
* `none` — контейнер без сети

Посмотреть список сетей:

```bash
docker network ls
```

При обычном `docker run ...` контейнер попадает в сеть `bridge`, если явно не указано другое.

---

## 2. Bridge-сеть (по умолчанию)

`bridge` — это **частная внутренняя сеть**, которую Docker создает на хосте

Характеристики:

* у сети есть свой диапазон IP-адресов, обычно что-то вроде `172.17.0.0/16`
* каждый контейнер в этой сети получает **внутренний IP** (например, `172.17.0.2`)
* контейнеры в одной bridge-сети могут общаться друг с другом по:

  * внутреннему IP
  * имени контейнера (через встроенный DNS).

По умолчанию все контейнеры, запущенные без `--network`, попадают именно в эту сеть.

---

## 3. Публикация портов: доступ извне

Внутренний IP контейнера виден только внутри хоста.
Чтобы обратиться к сервису из внешнего мира, нужно **пробросить порт**:

```bash
# формат
docker run -p <порт_хоста>:<порт_контейнера> <образ>

# пример: nginx внутри слушает 80, снаружи хотим 8080
docker run -p 8080:80 nginx
```

Что это значит:

* внутри контейнера приложение слушает `0.0.0.0:80`;
* на хосте он доступен по `localhost:8080` (или по IP хоста: `IP_хоста:8080`).

Без `-p` сервис остается доступным только **изнутри той же сети Docker** (другими контейнерами и хостом напрямую).

---

## 4. Сеть host

Сеть `host` выключает сетевую изоляцию: контейнер **делит сетевой стек с хостом**.

Запуск:

```bash
docker run --network host <образ>
```

Особенности:

* контейнер использует **IP-адрес хоста**
* порты **общие** с хостом:

  * приложение, слушающее порт 5000 в контейнере, будет доступно как `IP_хоста:5000`
  * `-p` не нужен и не работает как обычно
* нельзя запустить два контейнера, слушающих один и тот же порт, если они оба в `host`-сети (порт уже занят на хосте).

Используется редко, когда нужна максимальная производительность/прозрачность сети и осознанно жертвуются изоляцией.

---

## 5. Сеть none

Сеть `none` полностью отключает сеть у контейнера:

```bash
docker run --network none <образ>
```

Контейнер:

* не имеет IP в Docker-сетях
* не может выйти в интернет
* не может связаться с другими контейнерами.

Варианты применения:

* максимально изолированные задачи
* отладка, когда сеть не нужна.

---

## 6. Пользовательские bridge-сети

По умолчанию у нас есть одна bridge-сеть (`bridge`), куда сваливается все подряд.
Часто удобно **разделять контейнеры по логическим сетям**.

Создание своей сети:

```bash
docker network create \
  --driver bridge \
  --subnet 192.168.50.0/24 \
  my-app-net
```

Здесь:

* `--driver bridge` — тип сети
* `--subnet` — диапазон адресов (можно не указывать, если не критично)
* `my-app-net` — имя сети.

Запуск контейнеров в этой сети:

```bash
docker run --network my-app-net --name web nginx
docker run --network my-app-net --name db  mysql
```

Результат:

* контейнеры `web` и `db` видят друг друга внутри сети `my-app-net`
* их можно опрашивать по именам: `db`, `web`
* другие контейнеры (не в этой сети) к ним по внутреннему имени/адресу не достучатся.

Это базовый способ **логически изолировать** разные приложения на одном Docker-хосте.

---

## 7. Имена контейнеров и встроенный DNS

Docker поднимает **встроенный DNS-сервер** для контейнеров в bridge-сетях.

Что это дает:

* контейнеры могут обращаться друг к другу по имени, а не по IP:

  ```text
  веб-сервис → host=db → стучится в MySQL-контейнер по имени db
  ```

* если контейнер пересоздать и IP сменится, имя останется тем же — конфиги не нужно править.

Это стандартный и правильный способ связи сервисов: **использовать имена контейнеров / сервисов**, а не «зашитые» IP.

---

## 8. Полезные команды по сетям

Посмотреть список сетей:

```bash
docker network ls
```

Посмотреть детали по конкретной сети:

```bash
docker network inspect my-app-net
```

Посмотреть, к каким сетям подключен контейнер и какой IP у него внутри:

```bash
docker inspect <имя_или_id_контейнера>
# секция NetworkSettings → Networks
```

Подключить уже запущенный контейнер к сети:

```bash
docker network connect my-app-net my-container
```

Отключить контейнер от сети:

```bash
docker network disconnect my-app-net my-container
```

