# Образы Docker и Dockerfile

## 1. Что такое образ и контейнер

* **Образ (image)** — неизменяемый слепок (набор слоёв) с системой и приложением.
* **Контейнер (container)** — запущенный экземпляр образа (процесс с изоляцией).

Если говорить простыми словами: образ похож на установочный дистрибутив, а контейнер — это уже установленная и запущенная программа.

---

## 2. Когда нужен свой образ

* В публичных репозиториях **нет** нужного сервиса или сборки.
* Возникает задача **контейнеризировать** своё приложение ради единообразной сборки и доставки.
* Требуется особая среда компиляции или зависимостей для CI/CD.

---

## 3. Логика Dockerfile (минимальный набор)

Dockerfile — это **список инструкций**. Каждая строка говорит Docker, что нужно сделать.

Базовые инструкции:

* `FROM <image>` — базовый слой (часто Ubuntu/Alpine или официальный runtime).
* `RUN <cmd>` — выполнить команды (например, установить пакеты).
* `COPY <src> <dst>` — скопировать файлы из папки проекта внутрь образа.
* `ENTRYPOINT ["cmd", "arg"]` — команда, с которой образ будет **запущен как контейнер**.

Любой Dockerfile начинается с `FROM`. Это как «выбор основы», на которую дальше наслаиваются шаги.

---

## 4. Слои и кэш

* Каждая инструкция создаёт **новый слой**.
* Слои **кэшируются**: если команда не изменилась, Docker использует готовый слой → сборка быстрее.
* Чтобы не пересобирать всё при каждом изменении кода, часто сначала копируют `requirements.txt` и ставят зависимости, а исходники копируют ниже.

Пример проверки слоёв:

```bash
docker history <имя_образа>
```

---

## 5. Практика: Flask-микросервис

### 5.1. Структура проекта

```
app/
  app.py
  requirements.txt
Dockerfile
```

**`app/app.py`**

```python
from flask import Flask
app = Flask(__name__)

@app.get("/")
def index():
    return "Hello from Docker!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
```

**`requirements.txt`**

```
flask==3.0.0
```

### 5.2. Dockerfile (пример)

```dockerfile
FROM python:3.12-slim
WORKDIR /opt/app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app ./app

ENTRYPOINT ["python", "-m", "app.app"]
```

Комментарий:

* `ENTRYPOINT` задаёт команду, которая запустится первой. Именно этот процесс будет «держать» контейнер в работе.

### 5.3. Сборка и запуск

```bash
# Сборка с тегом
docker build -t yourname/flask-hello:1.0 .

# Локальный запуск
docker run --rm -p 8080:8000 yourname/flask-hello:1.0
```

Откройте в браузере: [http://localhost:8080](http://localhost:8080)

Здесь порт 8000 слушает приложение **внутри контейнера**, а 8080 доступен на вашей машине.

### 5.4. Публикация в реестр

```bash
# (однократно) необходимо залогиниться
docker login

# Публикация образа в Docker Hub
docker push yourname/flask-hello:1.0
```

---

## 6. Как «думать Docker’ом»

Если бы вы устанавливали сервис вручную, шаги выглядели бы так:

1) поставить ОС → 2) обновить пакеты → 3) установить Python → 4) поставить Flask → 5) скопировать код → 6) запустить сервер.

В Dockerfile эти шаги превращаются в инструкции. То есть Dockerfile — это просто «записанный сценарий установки».
