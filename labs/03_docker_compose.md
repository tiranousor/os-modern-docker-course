# ЛР: Redis + Rocket Counter. От `docker run` к `docker compose` и масштабированию

## 1. Цель работы

* Научиться запускать контейнеры с параметрами (имя, порты, связи).
* Закрепить работу с устаревшим `--link` (для понимания исторического контекста).
* Описать стек из 2 сервисов в `docker-compose.yml`.
* Масштабировать сервисы средствами Docker Compose и корректно завершать стек.

## 2. Что должно получиться

Кнопочное веб-приложение **rocketcounter** считает клики, храня значение в **Redis**.
Вы поднимете его:

1. вручную (`docker run`), затем
2. через `docker compose`, и
3. увеличите число экземпляров приложения.

---

## 4. Задание и порядок выполнения

### Часть 1. Запуск вручную (контейнеры `docker run`)

1. **Создайте Redis** (имя контейнера строго `redis`, образ `redis`).
   **Проверка:** `docker ps` показывает контейнер `redis` в состоянии `Up`.

2. **Создайте приложение rocketcounter** из образа `rotorocloud/rocket-counter` (найти можно в docker desktop, но лучше сразу написать команду),
   свяжите с Redis при помощи `--link` и опубликуйте на **8085** хоста (в контейнере порт **5000**).

> Связь с Redis: 
   ```bash
  --link redis:redis
   ```

   **Проверка:**

   * `docker ps` — контейнер `rocketcounter` слушает `0.0.0.0:8085->5000/tcp`.
   * `curl -s localhost:8085 | head` — возвращается HTML страницы счетчика.
   * Нажмите **GET A ROCKET** в браузере (или обновляйте страницу) и убедитесь, что число растет.

> Примечание: `--link` исторически устарел. В этой части используем его намеренно, чтобы увидеть ручную связку. В Compose он не нужен.

3. **Удалите контейнеры redis и rocketcounter**.

---

### Часть 2. Описание стека в `docker-compose.yml`

1. Создайте каталог `/root/rocketcounter` и перейдите в него.

2. Создайте файл **`docker-compose.yml`** со следующими требованиями:

   * Сервис **`redis`**: `image: redis`.
   * Сервис **`rocketcounter`**: `image: rotorocloud/rocket-counter`.
   * Приложение работает на порту **5000** в контейнере, опубликовать на **8085** хоста.
   * Связь `rocketcounter` ↔ `redis` должна обеспечиваться средствами Compose (общая сеть по умолчанию). `links` в Compose **не требуются**.

3. **Запустите стек**

   **Проверка:**

   * `docker compose ps` — оба сервиса `Up`.
   * `curl -s localhost:8085 | head` — страница открывается, счетчик работает.

---

### Часть 3. Масштабирование приложения

> Важно: на **одном хосте** публиковать **один и тот же** фиксированный порт (8085) на **нескольких репликах** невозможно. Поэтому для масштабирования на одном узле используйте один из вариантов ниже.

Измените публикацию портов на динамическую (эпемерные порты для каждого экземпляра):

```yaml
ports:
  - "0:5000"     # хост выберет свободный порт автоматически
```

Примените изменения и масштабируйте:

```bash
docker compose up -d --scale rocketcounter=2
docker compose ps
```

**Проверка:** в выводе у обоих экземпляров `rocketcounter` будут **разные** хост-порты (например, 49153 и 49154).
Откройте оба URL (из `docker compose ps`) и убедитесь, что счётчик общий (хранится в одном Redis).

---

### Часть 4. Полное уничтожение стека

```bash
docker compose down -v
```

**Проверка:**

* `docker ps -a | grep -E 'rocketcounter|redis'` — пусто.
* `docker network ls | grep rocketcounter` — пусто.

---

## 5. Что сдавать

1. Скриншоты или копии выводов проделанных шагов (оформить в README).
2. Файл `docker-compose.yml`, выложенный на github (финальная версия, которой вы пользовались при масштабировании).
3. Ссылку на репозиторий.

---

## 6. Вопросы

1. Зачем в Ч.1 использовался `--link` и почему в Compose он не нужен?
2. Чем отличается `image` от `build` в Compose?
3. Почему нельзя масштабировать сервис с публикацией фиксированного порта на одном хосте? Перечислите способы обойти это ограничение.
4. Что делает `docker compose down -v` и чем отличается от `down` без `-v`?
5. Как в Compose обеспечивается сетевое имя сервиса для обращения из другого сервиса?
